# 第六章

# 第七章 虚拟机类加载机制
## 写在前面的话
1. 虚拟机如何加载class文件？
2. class文件中的信息进入到虚拟机后会发生什么变化？

## 7.1 知识点
1. 把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机
   直接使用的java类型，这就是`虚拟机类加载机制`
2. java天生可以动态扩展的语言特性就是依赖运行期间动态加载和动态连接这个特点实现的

## 7.2 类加载的时机（什么时候需要进行类的加载）
下图为类的生命周期：

![类的生命周期](img/c7.1.class.loading.lifecycle.png)

JAVA虚拟机规范没有强制约束，由虚拟机具体实现自由把握。但是对于初始化阶段，规范严格要求`有且只有5种情况`
必须立即对类进行『初始化』(而加载、验证、准备自然需要在此之前)
1. 遇到new(使用new关键字实例化对象)、getstatic(读取静态字段`被final修饰、已在编译期把结果放入常量池的除外`)、
   putstatic(设置静态字段`被final修饰、已在编译期把结果放入常量池的除外`)或invokestatic(调用类的静态方法)
   这4条字节码指令时，如果类没有进行过初始化，则先触发初始化
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则先触发初始化
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则先触发其父类初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，需要先初始化这个主类
5. 使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、
   REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发初始化

以上5种场景中的行为称为对一个类进行`主动引用`，除此之外，所有引用类的方式都不会触发初始化，称为`被动引用`

被动引用例子1：通过子类引用父类的静态字段，不会导致子类初始化
```java
package org.fenixsoft.classloading;
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}
public class SubClass extends SuperClass{
    static {
        System.out.println("SubClass init!");
    }
}
public class static void main(String[] args) {
    System.out.println(SubClass.value);
}
输出：SuperClass init!
```
被动引用例子2：通过数组定义引用类不会触发此类的初始化
```java
public class static void main(String[] args) {
    SuperClass[] sca = new SuperClass[10];
}
没有输出 //虚拟机会触发一个[Lorg.fenixsoft.classloading.SuperClass](虚拟机自动生成)的类初始化阶段
```
被动引用例子2：常量再编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
```java
package org.fenixsoft.classloading;
public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }
    public static final int value = 123;
}
public class static void main(String[] args) {
    System.out.println(ConstClass.value);
}
没有输出
```

## 7.3 类加载的过程

### 7.3.1 加载

### 7.3.2 验证

### 7.3.3 准备

### 7.3.4 解析

### 7.3.5 初始化