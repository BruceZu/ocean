
### 1.锁的实例



### 2.锁的实现原理

`自旋锁->阻塞锁`

``

`偏向锁`

`对象锁`

`公平锁/非公平锁`

`乐观锁/悲观锁`

#### 2.1 volatile原理（不能实现锁/同步功能，是个辅助）

#### 2.2 synchronized原理

`Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的`，但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。
而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间（Synchronized效率低原因），
这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK1.6以后为了减少这种重量级锁(获得锁和释放锁的性能消耗)的使用，
引入了“轻量级锁”和“偏向锁”，通过设置-XX:-UseBiasedLocking来禁用偏向锁

| 锁状态 | 25 bit | 4bit | 1bit | 2bit |
| -------- | -------- |-------- | -------- |-------- |
|  | 23bit / 2bit |  | 是否是偏向锁 |锁标志位 |
| 轻量级锁 | 指向栈中锁记录的指针 |  |  | 00 |
| 重量级锁 | 指向互斥量（重量级锁）的指针 |  |  | 10|
| GC标记 | 空 |  |  | 11 |
| 偏向锁 | 线程ID / Epoch | 对象分代年龄 | 	1 | 01|
| 无锁 | 对象的hashCode | 对象分代年龄  | 0 | 01|

#### 2.3 Lock原理

### 3.锁的实践
https://mp.weixin.qq.com/s/d3cFp0DRw0JXkgk5ZLF7Hg

https://mp.weixin.qq.com/s/N1L6l_AWb25PKDdttEegZQ

#### 3.1同进程多线程锁
#### 3.2同操作系统多进程锁
#### 3.3多机（分布式锁）