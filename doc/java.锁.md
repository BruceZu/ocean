
### 1 volatile原理（不能实现锁/同步功能，是个辅助）

### 2.锁

`乐观锁：`
- 每次去读数据的时候都认为别人不会修改，所以不会上锁
- 更新的时候采取在写时先读，然后加锁操作（一样则更新），如果失败则要重复读-比较-写的操作
- java中的基本都是通过CAS操作实现的(比较当前值跟传入值是否一样，一样则更新，否则失败)

`悲观锁：`
- 每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁
- java中的悲观锁有synchronized

>AQS框架下的锁则是先尝试CAS乐观锁去获取锁，获取不到，才会转换为悲观锁，如ReentrantLock

#### 2.1 synchronized原理（基于JVM的实现）

##### 2.1.1为什么

java的线程是映射到操作系统原生线程之上的，阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源

##### 2.1.2JAVA对象头、Mark word的基础知识（主要是锁对象的使用）
- Mark word是java对象数据结构中的一部分
- 锁存在Java对象头里
- Mark Word里存储的数据会随着锁标志位的变化而变化

| 锁状态 | 25 bit | 4bit | 1bit(偏向锁?) | 2bit(锁标志位) |
| -------- | -------- |-------- | -------- |-------- |
| 轻量级锁 | 指向栈中锁记录的指针 |  |  | 00 |
| 重量级锁 | 指向互斥量（重量级锁）的指针 |  |  | 10|
| GC标记 | 空 |  |  | 11 |
| 偏向锁 | 线程ID/Epoch | 对象分代年龄 | 	1 | 01|
| 无锁 | 对象的hashCode | 对象分代年龄  | 0 | 01|

##### 2.1.3锁的优化

偏向锁、轻量级锁的状态转化及对象Mark Word的关系

![](https://github.com/yr0918/ocean/raw/master/doc/img/lock.object.status.change.jpeg)

- 自旋锁和偏向锁->轻量级锁->重量级锁
- 重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁

###### 2.1.3.1偏向锁

`消除数据在无竞争情况下的同步原语（消除整个同步，连CAS操作都不做）`

- 参数 -XX:+UseBiasedLocking是否开启(默认true);-XX：BiasedLockingStartupDelay延迟激活(程序启动几秒钟)
- 可以提高带有同步但无竞争的性能，但是对于锁有多个线程竞争就显得多余

获取和撤销流程

![](https://github.com/yr0918/ocean/raw/master/doc/img/lock.biased.locking.png)

**获取**

当一个线程访问同步块并获取锁时，会在`对象头和栈帧中的锁记录里存储锁偏向的线程ID`，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，
而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下
Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

**撤销**

偏向锁使用了一种`等到竞争出现才释放锁的机制`，所以`当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁`。偏向锁的撤销，需要等待全局安全点
（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，
如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word，`要么重新偏向于其他线程，
要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程`

###### 2.1.3.2自旋锁

线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。

所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，`会出让时间片，所以其他线程依旧有申请锁和释放锁的机会`。

JDK1.6中-XX:+UseSpinning开启；
JDK1.7后，去掉此参数，由jvm控制；

###### 2.1.3.3轻量级锁

`减少数据在无竞争情况下的使用重量级锁带来的操作系统互斥量产生的性能消耗（使用CAS操作去消除同步使用的互斥量）`

![](https://github.com/yr0918/ocean/raw/master/doc/img/lock.lightweight.locking.png)

**获取**

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。
然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则`自旋获取锁`，
当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。

**撤销**

轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。如果失败，表示有其他线程尝试过获取该锁，
则要在释放锁的同时唤醒被挂起的线程

###### 2.1.3.4重量级锁

![](https://github.com/yr0918/ocean/raw/master/doc/img/java.thread.synchronized.monitor.jpg)

重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步
1. 同时只能有一个线程可以获取某个对象的monitor
2. 一个线程通过调用某个对象的wait()方法释放该对象的monitor并进入休眠状态，直到其他线程调用该对象的notify()或者notifyAll()再次获取该对象的monitor
3. 只有拥有该对象monitor的线程才可以调用该对象的notify()和notifyAll()方法，如果没有该对象monitor的线程调用了该对象的notify()或者notifyAll()方法将会抛出java.lang.IllegalMonitorStateException

###### 2.1.4对比

| 锁 | 优点 | 缺点 | 	适用场景 |
| -------- | -------- |-------- | -------- |
| 偏向锁 | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程使用自旋会消耗CPU | 追求响应时间,锁占用时间很短 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量,锁占用时间较长 |

#### 2.2 Lock原理（基于JDK的实现）

`公平锁/非公平锁`


### 3.锁的实践

`多个访问方对同一个资源进行操作，需要进行互斥，通常利用一个互斥方能够访问的公共资源来实现分布式锁`

#### 3.1同进程多线程锁

synchronized或者lock

#### 3.2同操作系统多进程锁

设定一个所有进程能够访问到的lock实施互斥（例如文件inode，应用可以共享的本地文件）

#### 3.3多机（分布式锁）

多台机器多个进程可以同时访问到的一个lock，例如redis
1. 多台机器上多个进程对这个锁进行争抢，例如在缓存上同时进行set key=123操作
2. 只有一个进程会抢到这个锁，即只有一个进程对缓存set key=123能够成功，不成功的进程下次再来抢
3. 抢到锁的进程对余额进行扣减
4. 扣减完成之后释放锁，即对缓存delete key=123

[方案](http://www.cnblogs.com/PurpleDream/p/5559352.html)
常用的四种方案:
1. 基于数据库表做乐观锁，用于分布式锁。
2. 使用memcached的add()方法，用于分布式锁。
3. 使用redis的setnx()、expire()方法，用于分布式锁。
4. 使用redis的setnx()、get()、getset()方法，用于分布式锁。

不常用但是可以用于技术方案探讨的:
1. 使用memcached的cas()方法，用于分布式锁。
2. 使用redis的watch、multi、exec命令，用于分布式锁。
3. 使用zookeeper，用于分布式锁。
4. 基于Chubby分布式的文件的分布式锁

