# MYSQl
## 知识点
###### 尽量避免SELECT *命令
增加了磁盘需要操作的时间，还是在数据库服务器与WEB服务器是独立分开的情况下
###### 表数据类型选择
1. 能小就用小。表数据类型第一个原则是：使用能正确的表示和存储数据的最短类型。
   这样可以减少对磁盘空间、内存、cpu缓存的使用
2. 避免用NULL，这个也是网上优化技术博文传的最多的一个。理由是额外增加字节，
   还有使索引，索引统计和值更复杂。很多还忽略一个count(列)的问题，count(列)
   是不会统计列值为null的行数
3. 整型、整形优先原则:Tinyint、smallint、mediumint、int、bigint，分别需要
   8、16、24、32、64;能用tinyint的绝不用smallint;int(1) 和int(11)是一样的，
   唯一区别是mysql客户端显示的时候显示多少位;能用整形的不用其他类型替换，如ip可以转换成整形保存

###### 利用LIMIT 1取得唯一行
数据库引擎发现只有1后将停止扫描，而不是去扫描整个表或索引
###### JOIN操作
1. INNER JOIN（内连接,或等值连接）：取得两个表中存在连接匹配关系的记录。
2. LEFT JOIN（左连接）：取得左表（table1）完全记录，即是右表（table2）并无对应匹配记录。
3. RIGHT JOIN（右连接）：与 LEFT JOIN 相反，取得右表（table2）完全记录，即是左表（table1）并无匹配对应记录
4. cross join：交叉连接，得到的结果是两个表的乘积（假设集合A={a,b}，集合B={0,1,2}，
    则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}）
5. 性能：尽量用inner join.避免 LEFT/RIGHT JOIN 和 NULL
6. LEFT/RIGHT注意事项：

 - on与where的执行顺序：在使用Left (right) join的时候，一定要在先给出尽可能多的匹配满足条件，
    减少Where（从匹配阶段产生的数据中检索过滤）的执行
 - 注意ON 子句和 WHERE 子句的不同
 - 尽量避免子查询，而用join

## 索引
#### 索引中的优化
>索引（Index）是帮助MySQL高效获取数据的数据结构（索引是数据结构）

>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）
>数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引`

索引不仅是主键或唯一键。如果你想搜索表中的任何列，你应该一直指向索引

1. 索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从
   第1条记录开始然后读完整个表直到找出相关的行
2. 有本词典，数据就是书的正文内容，你就是那个cpu，而索引，则是书的目录
3. 普通索引、唯一索引、主键索引、组合索引
4. 索引越多越好？
    - 数据的变更（增删改）都需要维护索引，更多的索引意味着更多的维护成本
    - 更多的索引意味着也需要更多的空间 (一本100页的书，却有50页目录？)
    -  过小的表，建索引可能会更慢哦(读个2页的宣传手册，你还先去找目录？)
5. 尽量减少like，但不是绝对不可用，”xxxx%” 是可以用到索引的
6. 除了like，以下操作符也可用到索引：<，<=，=，>，>=，BETWEEN，IN
    以下则不行<>，not in ，!=，like “%xxx”，or
7. 什么样的字段不适合建索引？
    - 一般来说，列的值唯一性太小（如性别，类型什么的），不适合建索引
    - 太长的列，可以选择只建立部分索引，（如：只取前十位做索引）
    - 更新非常频繁的数据不适宜建索引（怎样叫非常？意会）
8. 一次查询不能用多个索引

#### 索引的实现
>为什么使用B-Tree（B+Tree）

1. 主存存取原理
2. 磁盘存取原理
3. 局部性原理与磁盘预读

##### MyISAM存储引擎索引实现 `“非聚集”索引`
![主索引的B+数图](https://github.com/yr0918/ocean/raw/master/doc/img/mysql_myisam_btree_primary_key.png)

![辅助引的B+数图](https://github.com/yr0918/ocean/raw/master/doc/img/mysql_myisam_btree_sencond_key.png)

1. 索引文件和数据文件分离
2. MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址
3. 主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复

##### InnoDB存储引擎索引实现 `“聚集”索引（叶节点包含了完整的数据记录）`
![主索引的B+数图](https://github.com/yr0918/ocean/raw/master/doc/img/mysql_innodb_btree_primary_key.png)

![辅助引的B+数图](https://github.com/yr0918/ocean/raw/master/doc/img/mysql_innodb_btree_sencond_key.png)

1. 不分离，表数据文件本身就是按B+Tree组织的一个索引结构
2. 主索引的叶节点data域保存了完整的数据记录；辅助索引data域存储相应记录主键的值而不是地址
3. 如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，
   则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形
4. 不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大
5. 用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键
   会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主
   键则是一个很好的选择
